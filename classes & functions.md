# Введение в классы и функции.

Большинство современных языков 
(Java, Python и многие другие) 
являются объектно-ориентированными,
то есть в них есть специальные вызываемые
объекты: _классы_ и _функции_.

> **Функции** выполняют определённые участки кода,
> отдельно от основной программы 
> и могут быть вызваны в любое время.
> 
> Функция может принимать в себя какие-либо
> аргументы, а так же возвращать их

Вот пример функции вывода фразы ``Hello World``,
она не принимает в себя никаких аргументов,
и так же ничего не возвращает

    def hello():
        print("Hello World")

А вот пример использования функций
для подсчёта суммы чисел в списке.
Здесь функция принимает аргумент ``spisok``,
который является списком из чисел,
и возвращает аргумент ``summa``,
который является суммой чисел списка

    def get_summa(spisok):

        summa = 0
        for chislo in spisok:
            summa = summa + chislo

        return summa

Если мы вызовем эту функцию, передав в неё
``[2, 4, 3]``, то функция вернёт нам число ``9``

    spisok = [2, 4, 3]
    summa = get_summa(spisok)
    print(summa)

Данная программа выведет в терминал ``9``.

Основное преимущество функций заключается в том, 
что многие часто используемые части кода можно
вынести в отдельную функцию, и не прописывать
каждый раз одно и то же, а просто вызывать нужную
функцию, передавая необходимые аргументы. 

Например, стоит вынести подсчёт суммы списка 
в отдельную функцию, если нужно подсчитать 
эту сумму несколько раз, или подсчитать её
для разных списков.

Или стоит вынести в отдельную функцию 
вывод надписи ``Игра окончена``, 
если для окончания игры существует 
несколько различных условий, при которых
Игра будет окончена. Например, если у игрока 
не осталось жизней, или если все враги 
уничтожены, наступает концовка. 
Её лучше вынести в отдельную функцию.

> **Класс** это пользовательский объект,
> со своими уникальными аттрибутами и функциями.
> Так же классы при создании могут "наследовать"
> другие классы - то есть перенимать все
> аттрибуты и функции класса-родителя.

Для каждого объекта, созданного пользователем,
или предустановленными в стандартном пакете
Python (list, dict, и т.ж.) характерна запись

    class ClassName:
        def __init__(self):
            # some action
        def other_function1(self):
            # some action
        def other_function2(self, argument1, argument2):
            # Some action
        def other_function3(self, arguments):
            # some_action
            return some_argument

Здесь ``ClassName`` это имя класса, функция
``__init__`` это стандартная функция, которая
выполняется каждый раз при вызове класса.
Функция ``other_action`` это функция, 
выполняющая какое-то действие с объектами 
этого класса, таких функций может быть
сколько угодно для любого объекта. Они могут
принимать аргументы, или не принимать,
возвращать какие-то объекты или нет. В общем, 
работают аналогично стандартным Python-функциям,
но вызывать их можно только в том случае, если был
вызван класс, которому такая функция принадлежит.
Так же, вызывая создавая такую функцию, 
первым аргументом всегд должнен быть ``self``, но
при вызовк такой функции этот аргумент никак не передаётся


Вот пример объекта, у которого есть
аттрибуты скорости, и местоположения,
а так же функция ``move``, в которой
происходит движение объекта вправо вверх

    class Ball:
        def __init__(self):
            self.x = 40
            self.y = 80
            self.speed = 5

        def move(self):
            self.x = self.x + self.speed
            self.y = self.y + self.speed

На практике использование такого класса будет
выглядеть примерно таким образом

    ball = Ball()
    for step in range(10):
        ball.move()

Такой код создаст (вызовет) объект класса ``Ball``,
а так же последовательно сдвинет его 10 раз.

А вот пример наследуемого класса. К примеру, я хочу 
добавить нашему мячику возможность менять скорость

**Важно:** При вызове класса с наследованием, 
обязательно нужно вызвать класс-родитель при создании
командой ``super().__init__()``. Здесь мы обращаемся
к классу-родителю через метод ``super()`` и вызываем
у него функцию ``__init__()``. Таким же образом можно
вызвать и любую другую функцию родительского класса
``supper().some_function(some_argument)``. Это бывает
полезно при использовании класса, как шаблона для других
классов. Например в разработке игр это как правило 
такие классы, как ``Sprite`` (с англ. - объект в 2д играх)
или ему аналогичные. Для такого класса обычно задаются 
общие необходимые параметры, присущие каждому объекту
(расположение на экране, картинка, какие-то доп. аттрибуты),
а так же базовый набор функций (функция, которая выведет
картинку этого объекта на экран и т.д.)

    class Ball_new(Ball):
        def __init__(self):
            super().__init__()
        def change_speed(self, new_speed):
            self.speed = new_speed


Теперь у нашего нового мячика есть все те же свойства,
что и у оригинального шарика, но он так же может
менять свою скорость. пример для работы с таким шарико
будет выглядеть примерно вот так:

    ball = Ball_new()
    for step in range(5):
        ball.move()
    ball.change_speed(10)
    for step in range(5):
        ball.move()

Здесь мы создаём (вызываем) объект класса ``Ball_new``,
а так же последовательно сдвигаем его 5 раз, после чего 
меняем скорость и вновь сдвигаем мячик 5 раз.

Так же, как и с функциями, взаимодействовать 
можно и с аттрибутами класса вне его предела,
для этого нужно просто обратиться к конкретному
аттрибуту (при условии, что мы до этого вызвали 
нужный класс)

    ball = Ball_new()
    ball.speed = 10

работает точно так же, как и 

    ball = Ball_new()
    ball.change_speed(10)

В любом случае, любые взаимодействия с классом
стоит создавать в виде функций внутри самого 
класса. Это обеспечивает лучшую читабельность
и чистоту кода.

> Так же существуют и не вызываемые классы. 
> К аттрибутам таких классов можно обращаться
> даже не вызывая этот класс. В таких классах 
> аттрибуты не указываются в основной функции,
> а указываются перед ней.

Вот пример не вызываемого класса:

    class Settings:
        screen_width = 800
        screen_height = 600

И получить информацию из такого класса
можно просто обратившись к нему

    width = Settings.screen_width
    height = settings.screen_height

